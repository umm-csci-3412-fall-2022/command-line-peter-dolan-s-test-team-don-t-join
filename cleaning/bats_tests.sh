#!/usr/bin/env bats

# Tests initially written by Nic McPhee, August 2016
# See `git` history for additional contributions.

load '../test/test_helper/bats-support/load'
load '../test/test_helper/bats-assert/load'
load '../test/test_helper/bats-file/load'

# Create some local variables with the base names of the test
# directories and the expected number of remaining files.
little=little_dir
num_little_remaining_files=16
big=big_dir
num_big_remaining_files=792

#######################################
# Set up to be run before each test
#######################################
setup() {
  # Create a temporary scratch directory for the shell script to work in.
  BATS_TMPDIR=$(temp_make --prefix 'compiling-')
  # The next two lines simplify the display of the potentially long, 
  # complex paths generated by `temp_make` so the output of `bats` is
  # hopefully more readable. 

  # The comments below disable a shellcheck warning that would
  # otherwise appear on both these saying that these variables
  # appear to be unused. They *are* used, but in the bats-file
  # code, so shellcheck can't tell they're being used, which is
  # why I'm ignoring those checks for these two variables, and
  # BATSLIB_TEMP_PRESERVE_ON_FAILURE a little farther down.
  # shellcheck disable=SC2034
  BATSLIB_FILE_PATH_REM="#${BATS_TMPDIR}"
  # shellcheck disable=SC2034
  BATSLIB_FILE_PATH_ADD='<temp>'

  # Comment out the next line if you want to see where the temp files
  # are being created.
  echo "Bats temp directory: $BATS_TMPDIR"

  # This tells bats to preserve (i.e., not delete)
  # the temp files generated for failing tests. This might be 
  # useful in trying to figure out what happened when a test fails.
  # It also could potentially clutter up the drive with a bunch
  # of temp files, so you might want to disable it when you're not
  # in "full-on debugging" mode.
  # shellcheck disable=SC2034
  BATSLIB_TEMP_PRESERVE_ON_FAILURE=1

  # Confirm that the script file and the archive file both
  # (still) exist. If either don't, then we'll fail straight
  # away because none of the other tests make any sense.
  if [ ! -f big_clean.sh ]; then
    echo "# The script big_clean.sh does not exist." >&3
    echo "# Have you created the script? Did you spell the name correctly?" >&3
    exit 1
  fi
  if [ ! -f little_dir.tgz ]; then
    echo "# The archive little_dir.tgz does not exist." >&3
    echo "# Did you delete it or rename it?" >&3
    echo "# Did you possibly use 'gunzip' and change it to .tar?" >&3
    echo "# You can use 'git' to restore the archive file." >&3
    exit 1
  fi
  if [ ! -f big_dir.tgz ]; then
    echo "# The archive big_dir.tgz does not exist." >&3
    echo "# Did you delete it or rename it?" >&3
    echo "# Did you possibly use 'gunzip' and change it to .tar?" >&3
    echo "# You can use 'git' to restore the archive file." >&3
    exit 1
  fi

  # Copy the script and archive file to the temp directory
  # and `cd` there to do all the testing work.
  cp big_clean.sh little_dir.tgz big_dir.tgz "$BATS_TMPDIR"
  cd "$BATS_TMPDIR" || exit 1
}

#######################################
# Tear down to be run after each test
#######################################
teardown() {
  # Remove the temporary scratch directory to clean up
  # after ourselves.
  temp_del "$BATS_TMPDIR"
}

# If this test fails, your script file doesn't exist, or there's
# a typo in the name, or it's in the wrong directory, etc.
@test "big_clean.sh exists" {
  assert_file_exist big_clean.sh
}

# If this test fails, your script isn't executable.
@test "big_clean.sh is executable" {
  assert_file_executable big_clean.sh
}

# If this test fails, your script either didn't run at all, or it
# generated some sort of error when it ran.
@test "big_clean.sh runs successfully" {
  run ./big_clean.sh $little.tgz
  assert_success
}

# If this test fails, you either moved or renamed the compressed `tar` archive.
# One common way this can happen is if you used `gunzip` to uncompressed the
# archive, and then used `tar xf` to extract the contents in a separate step.
# That would leave the archive as `NthPrime.tar` instead of `NthPrime.tgz`.
@test "big_clean.sh doesn't remove or rename the compressed 'tar' archive" {
  run ./big_clean.sh "$little.tgz"
  assert_file_exist "$little.tgz"
}

# If this test fails, you probably used `gunzip` to uncompress the archive
# file before extracting its contents, leaving a '.tar` file behind. If you
# use `tar -z` you can uncompress and extract in one step with `tar`, leaving
# the original archive file unchanged.
@test "big_clean.sh doesn't create a '.tar' version of the archive" {
  run ./big_clean.sh "$little.tgz"
  assert_file_not_exist "$little.tar"
}

# If this test fails, you probably extracted the archive in the directory
# where the script was called instead of creating a temporary directory to
# do that work in. You want to create a temporary directory (using `mktemp -d`)
# and extract the archive contents to there (using the `-C` flag for `tar`).
# This ensures you don't clutter up the user's directory, and possibly
# overwrite files they have and want to keep.
@test "big_clean.sh doesn't extract in this directory" {
  run ./big_clean.sh "$little.tgz"
  assert_dir_not_exist "$little"
}

# If this test fails, you didn't create a file called `cleaned_little_dir.tgz`
# when your script was run on `little_dir.tgz`. This could mean you have
# the file name wrong, or you put the new tar file in the wrong
# directory.
@test "big_clean.sh creates new 'cleaned_little_dir.tgz' archive" {
  run ./big_clean.sh "$little.tgz"
  assert_file_exist "cleaned_$little.tgz"
}

# If this test fails you probably didn't get the "internal"
# directory structure for the archive correct. This is usually
# because you didn't tar the correct location in the directory
# structure. If, for example, you have entries in your new
# archive like `./file_1` then you passed the wrong arguments
# to `tar` when you created the new archive.
@test "The archive has the correct internal directory structure" {
  run ./big_clean.sh "$little.tgz"
  # List all the files in the new archive
  run tar -ztf cleaned_$little.tgz
  # The first line should be the target "internal" directory.
  assert_line --index 0 "little_dir/"
}

# If this test fails you didn't get the didn't delete/keep the correct number
# of files. Look at the test output and see what number you got
# compared to what was expected. If you got 0, then see if there's
# some other error (e.g., the file you created isn't a compressed
# tar archive). Use `tar -ztf cleaned_little_dir.tgz` to look at
# the contents of the tar archive you created and if that helps.
@test "The new archive has the right number of files in it" {
  ./big_clean.sh "$little.tgz"
  run bash -c "tar -ztf cleaned_$little.tgz | grep -P 'little_dir/file_\d+$' | wc -l"
  assert_output --regexp "\s*$num_little_remaining_files\s*"
}

# If this test fails you probably either removed a file you should
# have kept, or kept one that should have been deleted. This doesn't
# check *all* the files, so it's possible to pass this without
# actually doing the "right" thing, but with the other tests it's
# unlikely.
@test "The new archive has (at least some) of the right files in it" {
  ./big_clean.sh $little.tgz
  run tar -ztf cleaned_$little.tgz
  # Some lines that should be in the cleaned archive
  assert_line "little_dir/"
  assert_line "little_dir/file_1"
  assert_line "little_dir/file_10"
  assert_line "little_dir/file_19"
  # Some lines that should *not* be in the cleaned archive
  refute_line "little_dir/file_7"
  refute_line "little_dir/file_13"
}

# This is the same as the previous "right number of files" test,
# but on the big archive.
@test "big_clean.sh returns the right number of files on the big archive" {
  run ./big_clean.sh $big.tgz
  run bash -c "tar -ztf cleaned_$big.tgz | grep -P '^big_dir/file_\d+$' | wc -l"
  assert_output --regexp "\s*$num_big_remaining_files\s*"
}
